Отчет по анализу памяти в проекте Jobj_tracker
1. Открытие проекта и настройка среды
Открыл проект Jobj_tracker и перешел в пакет tracker.
Реализовал классы CreateManyItems и DeleteAllItems для массового добавления и удаления объектов соответственно.
В классе StartUI запустил программу с использованием хранилища MemTracker в режиме, который позволяет добавлять, удалять и получать данные.

2. Мониторинг памяти с использованием JConsole
Открыл терминал и запустил JConsole для визуального анализа использования памяти JVM.

Подключился к процессу StartUI через JConsole и оценил начальные параметры:

Heap Memory Usage (Размер кучи): 20,971,520 байт (~20 МБ).
Classes (Количество загруженных классов): 2,313.
Threads (Количество потоков): 14.

3. Поведение памяти при работе приложения
Через некоторое время, после того как приложение выполняло различные операции, я заметил резкое снижение количества загруженных классов до 7,658,050 экземпляров. Это, вероятно, произошло из-за работы сборщика мусора, который освободил память от неиспользуемых объектов.
После стабилизации графиков использования памяти, я добавил 100,000 записей в MemTracker. Это привело к увеличению использования памяти, которая достигла 30,043,648 байт (~30 МБ).
Далее я добавил еще 100,000 записей, и память увеличилась до 67,792,384 байт (~68 МБ).

4. Анализ состояния памяти с помощью jmap
В терминале выполнил команду jps, чтобы получить PID текущего процесса.

На основании полученного PID, я выполнил команду jmap -histo <pid>, чтобы получить распределение объектов в памяти. Вот ключевая информация, полученная из дампа памяти:

 num     #instances         #bytes  class name (module)
-------------------------------------------------------
 1:        257,587      14,808,824  [B (java.base@17.0.5)  // Массив байтов.
 2:         14,424      10,492,608  [I (java.base@17.0.5)  // Массив целых чисел.
 3:        144,671       8,101,576  sun.util.calendar.ZoneInfo (java.base@17.0.5)  // Информация о временной зоне.
 4:        331,932       7,966,368  java.time.LocalDateTime (java.base@17.0.5)  // Дата и время.
 5:        331,805       7,963,320  java.time.LocalTime (java.base@17.0.5)  // Время без даты.
 6:        231,612       5,558,688  java.lang.String (java.base@17.0.5)  // Строки.
 7:        200,092       4,802,208  java.time.LocalDate (java.base@17.0.5)  // Даты.
 8:        200,000       4,800,000  ru.job4j.tracker.Item  // Класс Item из вашего приложения.
Эти данные логичны, так как массивы байтов и целых чисел, а также объекты, связанные с датой и временем, активно используются при создании новых объектов. Объем занимаемой памяти также совпадал с показателями в JConsole.

5. Удаление объектов и работа сборщика мусора
После удаления всех объектов класса Item, изменения в памяти не были заметны сразу. Это ожидаемое поведение, поскольку сборщик мусора еще не освободил память.
Использовал кнопку Perform GC в JConsole для явного запуска сборщика мусора, после чего объем памяти уменьшился до 4,466,344 байт (~4.5 МБ).
6. Тестирование на переполнение памяти (OutOfMemoryError)
Чтобы протестировать систему на устойчивость, я начал постепенно добавлять по 10,000,000 объектов.
С каждым шагом использование памяти увеличивалось.
На пятом шаге приложение завершилось с ошибкой Exception in thread "main" java.lang.OutOfMemoryError: Java heap space, что указывает на переполнение памяти (Heap Space).
К моменту возникновения ошибки, объем используемой памяти достиг 9 ГБ